function RES = RBE(MD,TPM,usedvar,varargin)
% R = RBE(MD,MDL,USED,...) - Recursive Bayesian Estimation test for (currently) two irradadiance
%   components: [kn,kd] given any number of sensors.
%
% INPUT: 
%   MD - MeteoData object, must include all variables used by TPM
%   TPM - Transition Probability density model(s). Table generated by KNKD_DENSITY_FIT
%   USED - cellstr. list of sensors to use as measurements, default is to use all sensors.
%
%   ..,'mainmdl',n/key - Use a model in the list TPM other than the first.
%   ..,'minP',1e-12 - Skip likelihood calculation for points where the prior falls below this
%           threshold. Used also to clip ignorance scores (avoid log(0)).
%   ..,'ndays',N - Reduce test to N random days in the data set.
%
%   ..,'-plot' - plot recursion steps
%   ..,'-benchmark' - calculate (and plot) deterministic benchmark
%
% OUTPUT: structure with Ntx1 vectors of error metrics (compared to "true" MD.kn, MD.kd).
%
%     RES.box - Box Ordinate Transform
%     RES.ignorance - Ignorance Scores
%     RES.energy - Energy Scores
%     RES.rmse - RMSE of deterministic benchmark
%     RES.map - Maximum a Posteriori
%     RES.PIT - Ntx2 Probability Integral Transform (marginal kn, and kd | kn)

    opt.ndays = Inf;
    opt.mainmdl = 1;
    opt.minP = 1e-12;
    % opt.method = 'bin';
    opt = parseoptions(varargin,{'-plot','-record','-benchmark'},opt,'restchk');
    
    NONO_FLAGS = {'NA','num','abs_phys','rel_phys','model','BSRN_abs_lo','BSRN_abs_hi','interp','UNC_lo','UNC_hi'};
    if ~isfield(MD,'kc')
        kc = MD.kt.*MD.ENI.*sind(MD.sunel)./MD.CSGHI;
        MD = addsource(MD,'kc',kc,strjoin(getsourceof(MD,{'kt','CSGHI'}),'/'));
        MD.flags.data.kt = bitor(MD.flags.data.kt,MD.flags.data.CSGHI);
        MD.flags = checkfield(MD.flags,MD,@(x) x >= 0,'abs_phys',{'kc'},false);
        MD.flags = checkfield(MD.flags,MD,@(x) x < 1.6,'rel_phys',{'kc'},false);
    end    
    MD = meteoQC.flagged2nan(MD,NONO_FLAGS);
    
    % PROVISIONAL: Kt, Kc should be state variables (see note below)
    % These will be used as seeds (e.g.for morning hours) and replaced by MAP estimates on runtime
    AVG_WINDOW = round(1/hours(MD.timestep));
    navg = @(x) circshift(movmean(x,[AVG_WINDOW-1,0],'omitnan'),1);
    MD = MD.addfield('Kt',navg(MD.kt));
    MD = MD.addfield('Kc',navg(MD.kc));

    g = recover_grids(TPM); g = g(1:2);
    [kn_grid,kd_grid] = ndgrid(g{:});
    
    try
    % start with conditional distribution on cos(z) = 0
        dawn = TPM{'cosz','interpolant'}{1}.Values(:,:,1);
    catch
    % start with uniform distribution
        dawn = ones(size(kn_grid));
    end
    
    % Parse (composite) prior models, get all external dependencies from MD
    [mainmdl,TPM,EXT] = modeldependencies(TPM,opt.mainmdl,MD);

    KNOWN = {'GTI','DHI','BNI','GHI','USW'};
    
    if nargin < 3 || (isempty(usedvar) && ~iscell(usedvar))
        usedvar = getsourceof(MD,intersect(fieldnames(MD),KNOWN));
    end
    
    % Get measurements Y
    usedvar = cellstr(usedvar);
    [Y,~,var_ix] = getbysource(MD,usedvar);
    types = MD.data.Properties.VariableNames(var_ix);
    
    Ny = size(Y,2);
    
    typ = cellfun(@(x) strcmp(types,x),KNOWN,'unif',0);
    typ = cell2struct(typ',KNOWN);
    
    [~,idx] = parselist(usedvar,{MD.sensors.ID});
    S = MD.sensors(idx);
    
    if opt.benchmark && ~all(typ.GTI)
    % TODO!- define benchmark for other sensor types
        warning('Benchmark is still not defined for non-GTI sensors');
        opt.benchmark = false;
    end
    
    % [surftilt,surfaz,IAM,sensor_list,sensor_labels] = getsensorinfo(MD.sensors,usedvar,typ);
    
    if any(typ.GTI)
        m = [S(typ.GTI).mount];
        surftilt = [m.tilt];
        surfaz = [m.azimuth];
    else
        surftilt = [];
        surfaz = [];
    end
    sensor_labels = strjoin(usedvar,'+');
    config_name = regexprep(matlab.lang.makeValidName(sensor_labels),'[\b_]','');

    if any(cellfun(@isempty,{S.fIAM})), S = checkIAM(S); end
       
    testname = strrep(mainmdl.Properties.UserData.name,'knkd_density_','');
    testname = [testname '_' mainmdl.Properties.RowNames{1} '_' config_name];

    [days,~,id] = unique(dateshift(MD.t,'end','day'));
    % worthit = accumarray(id,any(isfinite(Y),2) | MD.dark,[],@mean) > 0.8;
    
    rng(1234);
    picks = randperm(id(end),min(id(end),opt.ndays));
    
    % Point distances for Energy Score
    x0 = [kn_grid(:),kd_grid(:)];
    Dxixj = pdist(x0,'euclidean');
    Dxixj = squareform(Dxixj);
    w = point_weights(g{:});
    
    RES.PIT = NaN(MD.Nt,2);
    RES.box = NaN(MD.Nt,1);
    RES.ignorance = NaN(MD.Nt,1);
    RES.energy = NaN(MD.Nt,1);
    RES.rmse = NaN(MD.Nt,1);
    RES.map = NaN(MD.Nt,3);
    RES.w = w;
    RES.g = g;
    
%     RES.mapi = NaN(MD.Nt,3);
%     [g{:}] = ndgrid(g{:});
%     G = griddedInterpolant(g{:},dawn,'makima');
%     searchopt = optimset(optimset('fminsearch'),'TolX',1e-4,'Display','none');
%     
%     function [x,y] = nearbymax(V,x0,y0)
%         G.Values = double(V);
%         fn = @(x) -G(x(1),x(2));
%         [x,y] = fminsearch(fn,double(x0),searchopt);
%         y = -y;
%         if y < y0
%             x = x0; y = y0;
%             keyboard();
%         end
%     end
    
    if Ny > 1 && opt.benchmark
        eg = [{single(1:Ny)},g];
        [eg{1:3}] = ndgrid(eg{:});
        ErrInterp = griddedInterpolant(eg{:},rand(size(eg{1}),'single'));
    end
    
    if Ny > 1
        searchopts = optimset('tolx',1e-4,'tolfun',1e-2,'display','off');
    end
    
    warning_resetter = naptime({'MATLAB:contour:ConstantData',...
                                'MATLAB:legend:IgnoringExtraEntries'}); %#ok<NASGU>

    if opt.plot
        lbl = {'Prior',mainmdl.texlbl{1};
               'Likelyhood',['$ P(y_i \mid x_i),\,y_i = ' sensor_labels '$'];
               'Posterior','$ P(x_i \mid Y_i)$'};    
        ax = plotstep(lbl);
    end
    
    window = hours(1)/MD.timestep; % PROVISIONAL
    
    np = numel(picks);
    wb = optwaitbar(0,'RBE','UI',false);
  
    for k = 1:np
        d = picks(k);
        wb.update(k/np,sprintf('Day %d/%d\n',k,np),'-addtime');
        
        if opt.plot && opt.record
            videoname = ['./fig/' testname '_' config_name '_' datestr(days(d),'yyyymmdd')];
            video = VideoWriter(videoname); %#ok<TNMLP>
            video.FrameRate = 5; 
            open(video)
        end
        
        R = dawn;
        for t = find(id == d)'

            if MD.sunel(t) < 0, continue; end
            
            % Prior
            P = getprior(R,TPM,EXT(t,:));
            P = P./sum(P.*w,1:2);
            if all(isnan(P)), P(:) = 1; end

            lkly = ( P > opt.minP ); 
            Q = single(lkly);
            
            % Likelihood
            [Q(lkly),E] = getlikelyhood(Y(t,:),S,typ,kd_grid(lkly),kn_grid(lkly),...
                                        MD.ENI(t),MD.sunel(t),MD.sunaz(t),MD.albedo(t),...
                                        surftilt,surfaz);
            Q = Q./sum(Q.*w,1:2);
            if all(isnan(Q)), Q(:) = 1; end
            
            % Posterior
            R = P.*Q;
            R = R./sum(R.*w,1:2);
            
            valid = isfinite(Y(t,:));
            ny = nnz(valid);
            
            if opt.benchmark && ((opt.plot && ny > 0) || (ny == 1))
            % Benchmark for a single sensor: intersection of reverse-Perez and separation model
            
                [KD,KN,kd0,kn0] = reverse_perez(surftilt(valid),surfaz(valid),Y(t,valid),MD.ENI(t),...
                                  MD.sunel(t),MD.sunaz(t),MD.albedo(t),{S(valid).fIAM},[],'bin');
                
                if ny == 1 && ~isempty(kd0)
                % NOTE: take the mean if there's multiple intersections
                    RES.rmse(t) = mean(hypot(kd0 - MD.kd(t),kn0 - MD.kn(t)));
                end
            else
                kd0 = []; kn0 = []; KD = []; KN = [];
            end
            % if isempty(kd0), kd0 = NaN; end
            % if isempty(kn0), kn0 = NaN; end
                
            if isfinite(MD.kn(t)) && isfinite(MD.kd(t)) && any(isfinite(E),'all')
                if ny > 1 && opt.benchmark
                % Benchmark for multiple sensors: least RMSE from reverse-Perez
                
                    BIG = 1e4;
                    E(~isfinite(E)) = BIG;
                    ErrInterp.Values(:) = BIG;
                    ErrInterp.Values(:,lkly) = E';
                    
                    % start with min RMSE on grid
                    [~,idx] = min(sum(E.^2,2));
                    idx = find(lkly,idx);
                    x = [kn_grid(idx(end)),kd_grid(idx(end))];
                    
                    f = @(x) double(ErrInterp(1:Ny,repmat(x(1),1,Ny),repmat(x(2),1,Ny)));
                    f0 = f(double(x));
                    [x,~,residual] = lsqnonlin(f,double(x),[0,0],[1,1],searchopts);
                    if rssq(residual) > rssq(f0)
                        x = [kn_grid(idx(end)),kd_grid(idx(end))];
                    end
                    kn0 = x(1); kd0 = x(2);
                    RES.rmse(t) = hypot(kd0 - MD.kd(t),kn0 - MD.kn(t));
                end

                W = R.*w;
                
                cdf = cumsum(sum(W,2),1);
                RES.PIT(t,1) = interpn(kn_grid(:,1),cdf,MD.kn(t));
                cdf = cumsum(W,2)./sum(W,2);
                RES.PIT(t,2) = interpn(kn_grid,kd_grid,cdf,MD.kn(t),MD.kd(t));
                
                [map,idx] = max(R,[],1:2,'linear');
                RES.map(t,:) = [kn_grid(idx),kd_grid(idx),map];
                
                % [RES.mapi(t,1:2),RES.mapi(t,3)] = nearbymax(R,RES.map(t,1:2),RES.map(t,3));
                
                % PROVISIONAL: get moving-average Kt/Kc from the MAP estimate
                % Kt should strictly be a third (probabilistic) state variable, so that
                % the prior conditioned on Kt can be integrated on all P(Kt) > 0
                if contains('Kt',EXT.Properties.VariableNames)
                    MD.kt(t) = kn_grid(idx)+kd_grid(idx);
                    if t >= window && t < MD.Nt
                        EXT.Kt(t+1) = mean(MD.kt(t-window+1:t),'omitnan');
                    end
                end
                
                px = interpn(kn_grid,kd_grid,R,MD.kn(t),MD.kd(t));
                RES.ignorance(t) = -log2(max(opt.minP,px));
                RES.box(t) = 1-sum(W(R <= px),1:2);
                
                % TODO: Should the statistics be based on a discrete distribution, i.e. W instead of R?

                W = reshape(W,numel(w),[])';
                Dxxi = single(hypot(MD.kn(t)-x0(:,1),MD.kd(t) - x0(:,2)));
                RES.energy(t) = W*Dxxi - 0.5*sum(W.*(W*Dxixj),2);
            end

            if opt.plot
                plotstep(ax,kn_grid,kd_grid,P,Q,R,MD.kn(t),MD.kd(t),kn0,kd0,KN,KD,MD.sunel(t));
                drawnow()
                if opt.record, writeVideo(video,getframe(gcf)); end
            end
        end
        if opt.record, close(video); end
    end
end
    
function ax = plotstep(ax,x,y,P,Q,R,x0,y0,xe,ye,Xt,Yt,sunel)

    persistent H
    try cellfun(@delete,H); end %#ok<TRYNC>
    
    if nargin < 2
    % Setup
        
        H = {};
        GUIfigure('RBE','',[100 200 1600 650]); clf();
        lbl = ax;
               
        set(gcf,'color','w');
        colormap(flipud(colormap('parula')));
        ax = arrayfun(@(j) subplot(1,3,j),1:3);
        for j = 1:3
            knkd_density_plot({[0,1],[0,1]},ones(2,2),'cdf','ax',ax(j));
            title(ax(j),[lbl{j,1},newline(),lbl{j,2}],'interpreter','latex','fontsize',12);
            hold(ax(j),'all');
        end
        return;
    end  

    cb = get(ax(1).Parent,'children');
    cb = cb(contains(arrayfun(@class,cb,'unif',0),'ColorBar'));
    
    w = point_weights(x(:,1),y(1,:));

    H{1} = cdfcontour(ax(1),P,cb(1));
    % [~,H{1}] = contour(ax(1),x,y,log10(P),LVL);
    
    if ~isempty(Xt)
        kt = 0:0.01:1.6;
        [kd,kn] = diffuse_fraction(kt,90-sunel,'sot2');
        kd = kd.*kt;
        H{2} = plot(ax(1),kn,kd,'m-');
        legend(ax(1),[H{1:2}],'AKDE','SOT2 sep. model','edgecolor','w');
    end
    
    % [~,H{3}] = contour(ax(2),x,y,log10(Q),LVL);
    H{3} = cdfcontour(ax(2),Q,cb(2));
    
    if ~isempty(Xt)
        H{4} = plot(ax(2),Xt,Yt,'m-');
        legend(ax(2),cat(1,H{3:4}),'Perez (ensemble)','Inv. Perez (det.)','edgecolor','w');
    end
    
    % [~,H{5}] = contour(ax(3),x,y,log10(R),LVL);
    H{5} = cdfcontour(ax(3),R,cb(3));
    H{6} = plot(ax(3),x0,y0,'ro','markersize',10);
    
    [~,idx] = max(R,[],1:2,'linear');
    H{7} = plot(ax(3),x(idx),y(idx),'b+','markersize',10);
    
    if ~isempty(xe)
        H{8} = plot(ax(3),xe,ye,'mx','markersize',10);
        legend(ax(3),cat(1,H{5:8}),'RBE Posterior','True (measured)','MAP','Deterministic','edgecolor','w');
    else
        legend(ax(3),cat(1,H{5:7}),'RBE Posterior','True (measured)','MAP','edgecolor','w');
    end
    
    function H = cdfcontour(ax,P,cb)
        
        PRCTILES = [50 75 95 99];

        lvl = prctilew(P,(100-PRCTILES),P.*w);
        lvl = unique(-log10(lvl(lvl > 0)),'sorted');
        if numel(lvl) < 2
            caxis(ax,[0,1]);
            cb.Ticks = [0,1];
            H = plot(0,0);
            return
        end

        ncolors = max(10,2*numel(lvl)+1);
        colormap(ax,parula(ncolors));
        
        [~,H] = contour(ax(1),x,y,-log10(P),lvl);

        caxis(ax,[lvl(1),lvl(end)]+[-0.5,0.5]*(lvl(end)-lvl(1))/ncolors);
        cb.Ticks = lvl;
        cb.TickLabels = arrayfun(@(x) sprintf('%g%%',x),PRCTILES,'unif',0);
    end
end

function [main,TPM,EXT] = modeldependencies(TPM,main,MD)
% [M,B,E] = modeldependencies(TPM,'main',MD) - find TPM row M matching model 'main', and if it is
%   a composite model, return the underlying models B (otherwise B = M). If any B is conditioned
%   on external variables, return these as a table E, with field names matching the keys of B.

    if ~isnumeric(main)
        [~,main] = is_synonym(main,TPM.Properties.RowNames);
    end
    validateattributes(main,{'numeric'},{'scalar','integer','positive','<=',numel(TPM)});
    
    if isempty(TPM.interpolant{main}) % && contains(mdl.Properties.RowNames{main},'x')
        elements = strsplit(TPM.Properties.RowNames{main},'x');
        elements = regexprep(elements,'\((.*)\)','$1');

        [~,ie] = is_synonym(elements,TPM.Properties.RowNames);
        assert(all(ie > 0),'Combination KEY does not match precalculated elements');
    else
        ie = main;
        % [~,ie] = ismember(main,mdl.Properties.RowNames);
    end
    main = TPM(main,:);
    TPM = TPM(ie,:);
    
    available = fieldnames(MD);
    
    EXT = cell(1,numel(ie));
    for k = 1:size(TPM,1)
        req = setdiff(TPM.conditions{k},{'lastkd','lastkn'});
        if isempty(req), EXT{k} = zeros(MD.Nt,0,'single'); continue; end
        
        % Solve dependence from external variables
        [ic,iv] = ismember(req,available);
        if ~all(ic)
            error('Failed to find required %s', shortliststr(TPM.conditions{k}(~ic),'variable'));
        end
        assert(all(cellfun(@(f) isvector(MD.(f)),req)),...
            'Conditioning variables in MD are expected to be vectors');

        EXT{k} = MD.data{:,iv};
    end
    EXT = table(EXT{:},'VariableNames',TPM.Properties.RowNames');
    
end

function Px = getprior(last_Px,mdl,EXT)
% Integrate transition density estimate MDL weighted by last estimate LAST_PX, slicing accross
% external conditioning variables EXT.

    Px = 1;
    for k = 1:size(mdl,1)
        if isempty(mdl.conditions{k})
            Px = Px.*mdl.interpolant{k}.Values;
            continue;
        end

        % Solve dependence from last state, distributed with P(kn,kd) = P0
        [ic,iv] = ismember({'lastkn','lastkd'},mdl.conditions{k});
        if any(ic)
            % make kn,kd the last dimensions...
            d = numel(mdl.conditions{k})+2;
            if ~all(ic), iv(~ic) = d-1; d = d+1; end
            dimorder = 1:d;
            dimorder(iv+2) = 0;
            dimorder(1:d-2) = dimorder(dimorder ~= 0);
            dimorder(d-1:d) = iv+2;
            G = permute(mdl.interpolant{k}.Values,dimorder);
            % ... and reduce, weighting by last_Px
            G = sum(G.*shiftdim(last_Px,2-d),d-1:d);
            mdl.interpolant{k}.Values = G;
            mdl.interpolant{k}.GridVectors(iv(ic)+2) = [];
            mdl.conditions{k}(iv(ic)) = [];
        end
        if isempty(mdl.conditions{k})
            Px = Px.*mdl.interpolant{k}.Values;
            continue;
        end
        
        missing = [false,false,~isfinite(EXT{:,k})];
        if any(missing)
            dimorder = 1:numel(mdl.conditions{k})+2;
            G = mdl.interpolant{k}.Values;
            G = sum(G,dimorder(missing));
            G = permute(G,[dimorder(~missing),dimorder(missing)]);
            mdl.interpolant{k}.Values = G;
            mdl.interpolant{k}.GridVectors(missing) = [];
            mdl.conditions{k}(missing(3:end)) = [];
        end
        if isempty(mdl.conditions{k})
            Px = Px.*mdl.interpolant{k}.Values;
            continue;
        end
        
        % Generate query points for whole kn-kd grid at Nt test points
        q = mdl.interpolant{k}.GridVectors;
        [q{1:2}] = ndgrid(q{1:2});
        [s(1),s(2)] = size(q{1});
        q(3:end) = arrayfun(@(x) repmat(x,s),single(EXT{:,k}),'unif',0);
        
        % ... and evaluate PDF
        Px = Px.*mdl.interpolant{k}(q{:}); % N1 x N2 x Nt
    end
end

function [Q,E] = getlikelyhood(Y,S,typ,kd,kn,ENI,sunel,sunaz,albedo,surftilt,surfaz)
    
    G.BNI = ENI.*kn;
    G.DHI = ENI.*sind(sunel).*kd;
    G.GHI = G.DHI + G.BNI*sind(sunel);

    valid = isfinite(Y); % & isfinite(U);
    E = NaN(numel(G.BNI),numel(valid));
    
    [F1,F2,sF1,sF2,rF1F2,Se] = pvlmod_perezcoeffs(G.BNI,G.DHI,ENI,sunel);
    G.CSn = F1.*kd.*ENI;

    useful = valid & typ.GTI;
    if any(useful)
        ok = valid(typ.GTI);
        
        u = uncertainty(S(useful),Y(useful),sunaz,sunel,G.BNI+G.CSn)/1.96;
            
        [a,~,ISO,CS,HB,ALB] = pvlmod_perezgeom(surftilt(ok),surfaz(ok),sunel,sunaz);

        A = (CS - ISO);
        B = HB;

        ISO = (1-F1).*G.DHI.*ISO;
        CS = F1.*G.DHI.*CS;
        HB = F2.*G.DHI.*HB;
        BTI = G.BNI.*a;
        ALB = albedo.*G.GHI.*ALB;  
        
        iam = arrayfun(@(s,a) s.fIAM(acosd(a)),S(useful)',a);
        G_mdl = ISO + HB + ALB + (CS + BTI).*iam;
        
        E(:,useful) = G_mdl - Y(useful);
        
        sF1 = sF1.*G.DHI;
        sF2 = sF2.*G.DHI;
            
        if nnz(ok) == 1
            Se = sqrt(Se.^2+u.^2+(sF1.*A).^2+(sF2.*B).^2 + 2*rF1F2.*A.*B.*sF1.*sF2);
            Q = normpdf(E(:,useful),0,Se);
        else
            sigma = (A.*A').*shiftdim(sF1.^2,-2) + ...
                    (B.*B').*shiftdim(sF2.^2,-2) + ...
                    (A.*B'+A'.*B).*shiftdim(sF2.*sF1.*rF1F2,-2) + ...
                    eye(nnz(ok)).*permute(Se.^2+u.^2,[3,2,1]);
            Q = mvnpdf(E(:,useful),0,sigma);
        end
    else
        Q = 1;
    end

    fld = fieldnames(typ);
    for j = 1:numel(fld)
        useful = valid & typ.(fld{j});
        if ~any(useful), continue; end
        
        switch fld{j}
        case 'GTI', continue; % already handled
        case 'GHI', b = G.BNI+G.CSn;
        case 'DHI', b = G.CSn;
        case 'USW', b = albedo*(G.BNI+G.CSn);
        end
        u = uncertainty(S(useful),Y(useful),sunaz,sunel,b)/1.96;
        iam = arrayfun(@(s) s.fIAM(max(0,90-sunel)),S(useful));
        G_mdl = G.(fld{j}) - b.*(1-iam(:)').*sind(sunel);
    
        if ~isfield(typ,fld{j}) || strcmp(fld{j},'GTI'), continue; end

        useful = valid & typ.(fld{j});
        if any(useful)
            E(:,useful) = G_mdl - Y(useful);
            Q = Q.*prod(normpdf(E(:,useful)./u),2);
        end
    end
    Q(isnan(Q)) = 0;
end

