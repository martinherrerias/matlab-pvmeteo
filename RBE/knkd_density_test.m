function TPM = knkd_density_test(TPM,X0_test,varargin)
% TPM = KNKD_DENSITY_TEST(TPM,X_TEST,[KEYS]) - Calculate performance metrics for transition 
%   probability density models TPM (as generated by KNKD_DENSITY_FIT) using data X0_test. 
%   This will add fields:
%
%    TPM.ignorance = median Ignorance Score
%    TPM.energy = mean Energy Score
%    TPM.discrepancy = discrepancy of Box-Ordinate-Transform (BOT).
%
%   If KEYS ~= 'all' is provided, only models with those Row-Names will be evaluated.
%   
% TPM = KNKD_DENSITY_TEST(..,'-plot') - plot histograms of BOT, Ignorance- and Energy Scores 
%   for individual measurements on each of the tested models.
%
% See also: KNKD_DENSITY_FIT, KNKD_DENSITY_PREP

    opt.test = 'all';
    % opt.ndays = Inf;
    % opt.mainmdl = 1;
    opt.minP = 1e-9;
    % opt.method = 'bin';
    opt = parseoptions(varargin,{'-plot','-print'},opt,'dealrest',1);

    [N,M] = size(X0_test);
    VAR = X0_test.Properties.VariableNames;
    
    TPM.keys = TPM.Properties.RowNames;
    name = TPM.Properties.UserData.name;
    info = TPM.Properties.Description;
    LBL = parselist(VAR,fliplr(TPM.Properties.UserData.labels),'-matchcase');
    
    [opt.test,test_idx] = parselist(opt.test,TPM.keys,'-matchcase','-soft');
    if any(test_idx == 0)
        [ia,ib] = is_synonym(opt.test(test_idx == 0),TMP.keys);
        if ~all(ia)
            error(shortliststr(opt.test(~ia),'Unknown model'));
        end
        test_idx(test_idx == 0) = ib;
    end
    
    GRIDS = recover_grids(TPM,VAR);
    Ng = cellfun(@numel,GRIDS);

    TPM = table2struct(TPM,'toscalar',true);

    if opt.print
        printfig = @(name) print(gcf,'-dsvg','-r600',['./fig/' name '.svg']);
    else
        printfig = @(name) 0; % ... crickets
    end

    x0 = GRIDS(1:2);
    [x0{1},x0{2}] = ndgrid(x0{1:2});
    x0 = [x0{1}(:),x0{2}(:)];
    
    X0_test = X0_test{:,:};

    room = maxarraysize('single')/(size(x0,1)*N)/12;
    if room < 1
        rng(123);
        X0_test(rand(N,1) > room,:) = [];
        N = size(X0_test,1);
        warning('Test set too big to fit in memmory, using a %d random sample',N);
    end   
    X0_test = mat2cell(X0_test,size(X0_test,1),ones(1,M));
    
    % Point distances for Energy Score
    Dxixj = pdist(x0,'euclidean');
    Dxixj = squareform(Dxixj);
    Dxxi = pdist2([X0_test{1:2}],x0);

    % weights for trapezoidal integration
    w = point_weights(GRIDS{1},GRIDS{2});
    
    if ~isfield(TPM,'ignorance'), TPM.ignorance = NaN(numel(TPM.keys),1); end
    if ~isfield(TPM,'energy'), TPM.energy = NaN(numel(TPM.keys),1); end
    if ~isfield(TPM,'discrepancy'), TPM.discrepancy = NaN(numel(TPM.keys),1); end
    
    g0 = cell(1,3);
    [g0{1:3}] = ndgrid(GRIDS{1:2},single(1:N)');
    
    q0 = cell(1,3);
    [q0{1:3}] = deal(X0_test{1:2},single(1:N)');

    for j = test_idx(:)'
    try
        if isempty(TPM.interpolant{j}) && contains(TPM.keys{j},'x')
            elements = strsplit(TPM.keys{j},'x');
            elements = regexprep(elements,'\((.*)\)','$1');
            
            [~,ie] = is_synonym(elements,TPM.keys);
            assert(all(ie > 0),'Combination KEY does not match precalculated elements');
        else
            ie = j;
        end
        
        for k = ie
            d = numel(TPM.conditions{k})+2;
            [used,ib] = ismember(VAR,[{'kn','kd'},TPM.conditions{k}]);
            assert(nnz(used) == d);

            X_test = cell(1,nnz(used));
            X_test(ib(used)) = X0_test(:,used);

            % Generate query points for whole kn-kd grid at Nt test points
            q = GRIDS(used);
            if d == 2
                [q{:}] = ndgrid(q{1:2});
            else
                [q{1:3}] = ndgrid(q{1:2},X_test{3});
                
                if d > 3
                    q(4:end) = cellfun(@(x) repmat(shiftdim(x,-2),[Ng(1:2),1]),X_test(4:end),'unif',0);
                end
            end
            if k == ie(1), Px = TPM.interpolant{k}(q{:}); % N1 x N2 x Nt
            else, Px = Px.*TPM.interpolant{k}(q{:});
            end
        end
        Px = Px./sum(Px.*w,1:2);
        
        if ismatrix(Px)
            % PIT = interpn(q{:},cumsum(cumsum(W,1),2),X0_test{1:2});
            px = interpn(q{:},Px,X0_test{1:2});
        else
            % PIT = interpn(g0{:},cumsum(cumsum(W,1),2),q0{:});
            px = interpn(g0{:},Px,q0{:});
        end
        
        W = Px.*w;
        W = reshape(W,numel(w),[])';
        Px = reshape(Px,numel(w),[])';
        BOT = 1-sum(W.*(Px <= px),2);

        TPM.discrepancy(j) = discrepancy(BOT);
        
%         cdf = cumsum(sum(W,2),1);
%         TPM.PIT(j,1) = interpn(kn_grid(:,1),cdf,MD.kn(j));
%         cdf = cumsum(W,2)./sum(W,2);
%         TPM.PIT(j,2) = interpn(kn_grid,kd_grid,cdf,MD.kn(j),MD.kd(j));

        ign = -log2(max(px,opt.minP));
        TPM.ignorance(j) = median(ign,'omitnan');

        es = sum(W.*Dxxi,2) - 0.5*sum(W.*(W*Dxixj),2);
        TPM.energy(j) = sqrt(mean(es.^2));

        fprintf('%s: \tIGN = %0.1f\tES = %0.2f\tDBOT = %0.2f\n',...
            TPM.keys{j},TPM.ignorance(j),TPM.energy(j),TPM.discrepancy(j));

%         TPM.keys{j} = TESTS{j};
%         TPM.interpolant{j} = G;
%         TPM.conditions{j} = allcond;
% 
%         lbl = regexp(TPM.texlbl(ie),'\$(.*) = f(\(.*\))\$','tokens');
%         while iscell(lbl{1}), lbl = cat(1,lbl{:}); end
%         lbl(:,2) = arrayfun(@(f,a) [f,a{:}],char('e'+(1:size(lbl,1)))',lbl(:,2),'unif',0);
%         TPM.texlbl{j} = ['$' lbl{1} ' = ' strjoin(lbl(:,2),' \\cdot ') '$'];

        if opt.plot
            % GUIfigure('knkd_density_test_metrics'); clf();
            plot_metrics(ign,BOT,es,[],TPM.texlbl(j));
            printfig([name '_metrics_' TPM.keys{j}]);
        end
    end
    end

    TPM = struct2table(TPM);
    TPM.Properties.RowNames = TPM.keys; TPM.keys = [];
    TPM.Properties.Description = info;
    TPM.Properties.UserData.labels = [VAR;LBL]';
    TPM.Properties.UserData.name = name;
    
    TPM = sortrows(TPM,'discrepancy');
        
    % save([name,'.mat'],'TPM');
end

% Pure persistance
% X0 = [MD.kn,MD.kd,Kt,sind(MD.sunel),Kc,sKc,sKt,lastkn,lastkd];

