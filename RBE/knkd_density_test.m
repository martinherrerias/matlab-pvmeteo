function TPM = knkd_density_test(TPM,X0_test,varargin)
% TPM = KNKD_DENSITY_TEST(TPM,X_TEST,[KEYS]) - Calculate performance metrics for transition 
%   probability density models TPM (as generated by KNKD_DENSITY_FIT) using data X0_test. 
%   This will add fields:
%
%    TPM.ignorance = median Ignorance Score
%    TPM.energy = mean Energy Score
%    TPM.discrepancy = discrepancy of Box-Ordinate-Transform (BOT).
%    TPM.PIT_discrepancy = discrepancy of Probability Integral Transform (PIT) for kn, kd
%
%   If KEYS ~= 'all' is provided, only models with those Row-Names will be evaluated.
%   Default KEYS = 'new' evaluates only models that have not been tested already.
%   
% TPM = KNKD_DENSITY_TEST(..,'-plot') - plot histograms of BOT, Ignorance- and Energy Scores 
%   for individual measurements on each of the tested models.
%
% See also: KNKD_DENSITY_FIT, KNKD_DENSITY_PREP

    opt.test = 'new';
    % opt.ndays = Inf;
    % opt.mainmdl = 1;
    opt.minP = 1e-9;
    % opt.method = 'bin';
    opt.hold = [];
    opt = parseoptions(varargin,{'-plot','-print'},opt,'dealrest',1);
    if isempty(opt.hold), opt.hold = opt.plot && ~opt.print; end

    VAR = uniquecell(cat(2,'kn','kd',TPM.conditions{:}),'stable');
    X0_test = X0_test(:,VAR);
    [N,M] = size(X0_test);
    
    TPM.keys = TPM.Properties.RowNames;
    name = TPM.Properties.UserData.name;
    info = TPM.Properties.Description;
    LBL = parselist(VAR,fliplr(TPM.Properties.UserData.labels),'-matchcase');
    
    GRIDS = recover_grids(TPM,VAR);
    Ng = cellfun(@numel,GRIDS);

    TPM = table2struct(TPM,'toscalar',true);
    
    if ~isfield(TPM,'ignorance'), TPM.ignorance = NaN(numel(TPM.keys),1); end
    if ~isfield(TPM,'energy'), TPM.energy = NaN(numel(TPM.keys),1); end
    if ~isfield(TPM,'discrepancy'), TPM.discrepancy = NaN(numel(TPM.keys),1); end
    if ~isfield(TPM,'PIT_discrepancy'), TPM.PIT_discrepancy = NaN(numel(TPM.keys),2); end
    
    if contains(opt.test,{'new','missing'},'IgnoreCase',true)
        notgood = @(x) x == 0 | ~isfinite(x);
    	new = all(notgood([TPM.ignorance,TPM.energy,TPM.discrepancy,TPM.PIT_discrepancy]),2);
        opt.test = TPM.keys(new);
    end
    
    [opt.test,test_idx] = parselist(opt.test,TPM.keys,'-matchcase','-soft');
    if any(test_idx == 0)
        [ia,ib] = is_synonym(opt.test(test_idx == 0),TPM.keys);
        if ~all(ia)
            error(shortliststr(opt.test(~ia),'Unknown model'));
        end
        test_idx(test_idx == 0) = ib;
    end
    
    if opt.print
        printfig = @(name) print(gcf,'-dsvg','-r600',['./fig/' name '.svg']);
    else
        printfig = @(name) 0; % ... crickets
    end

    x0 = GRIDS(1:2);
    [x0{1},x0{2}] = ndgrid(x0{1:2});
    x0 = [x0{1}(:),x0{2}(:)];
    X0_test = X0_test{:,:};

    room = maxarraysize('single')/(size(x0,1)*N)/12;
    if room < 1
        rng(123);
        X0_test(rand(N,1) > room,:) = [];
        N = size(X0_test,1);
        warning('Test set too big to fit in memmory, using a %d random sample',N);
    end   
    X0_test = mat2cell(X0_test,size(X0_test,1),ones(1,M));
    
    % Point distances for Energy Score
    Dxixj = pdist(x0,'euclidean');
    Dxixj = squareform(Dxixj);
    Dxxi = pdist2([X0_test{1:2}],x0);

    % weights for trapezoidal integration
    w = point_weights(GRIDS{1},GRIDS{2});
    
    
    g0 = cell(1,3);
    [g0{1:3}] = ndgrid(GRIDS{1:2},single(1:N)');
    
    q0 = cell(1,3);
    [q0{1:3}] = deal(X0_test{1:2},single(1:N)');
    
    gcdf = cell(1,3);
    gcdf{3} = single(1:N)';
    for i = 1:2
        midpts = interpn(GRIDS{i},1);
        gcdf{i} = midpts([1,2:2:end,end]);
    end

    ax = [];
    for j = test_idx(:)'
        if isempty(TPM.interpolant{j}) && contains(TPM.keys{j},'x')
            elements = strsplit(TPM.keys{j},'x');
            elements = regexprep(elements,'\((.*)\)','$1');
            
            [~,ie] = is_synonym(elements,TPM.keys);
            assert(all(ie > 0),'Combination KEY does not match precalculated elements');
        else
            ie = j;
        end
        
        for k = ie
            d = numel(TPM.conditions{k})+2;
            [used,ib] = ismember(VAR,[{'kn','kd'},TPM.conditions{k}]);
            assert(nnz(used) == d);

            X_test = cell(1,nnz(used));
            X_test(ib(used)) = X0_test(:,used);

            % Generate query points for whole kn-kd grid at Nt test points
            q = GRIDS(used);
            if d == 2
                [q{:}] = ndgrid(q{1:2});
            else
                [q{1:3}] = ndgrid(q{1:2},X_test{3});
                
                if d > 3
                    q(4:end) = cellfun(@(x) repmat(shiftdim(x,-2),[Ng(1:2),1]),X_test(4:end),'unif',0);
                end
            end
            if k == ie(1), Px = TPM.interpolant{k}(q{:}); % N1 x N2 x Nt
            else, Px = Px.*TPM.interpolant{k}(q{:});
            end
        end
        Px = Px./sum(Px.*w,1:2);
        
        if d == 2
            px = interpn(q{:},Px,X0_test{1:2});
        else
            px = interpn(g0{:},Px,q0{:});
        end
        
        W0 = Px.*w;
        W = reshape(W0,numel(w),[])';
        Px = reshape(Px,numel(w),[])';
        BOT = 1-sum(W.*(Px <= px),2);
        TPM.discrepancy(j) = discrepancy(BOT);
        
        for i = 2:-1:1
            if d == 2
                cdf = cat(i,0,cumsum(sum(W0,[1:i-1,i+1:2]),i));
                PIT(:,i) = interpn(gcdf{i},cdf,X0_test{i});
            else
                cdf = cat(1,zeros(1,N),squeeze(cumsum(sum(W0,[1:i-1,i+1:2]),i)));
                PIT(:,i) = interpn(gcdf{i},q0{3},cdf,X0_test{i},q0{3});
            end
            TPM.PIT_discrepancy(j,i) = discrepancy(PIT(:,i));
        end

        ign = -log2(max(px,opt.minP));
        TPM.ignorance(j) = median(ign,'omitnan');

        es = sum(W.*Dxxi,2) - 0.5*sum(W.*(W*Dxixj),2);
        TPM.energy(j) = sqrt(mean(es.^2));

        fprintf('%s: IGN = %0.1f, ES = %0.2f\n',TPM.keys{j},TPM.ignorance(j),TPM.energy(j));

        if opt.plot
            % GUIfigure('knkd_density_test_metrics'); clf();
            ax = plot_metrics([ign,es,BOT,PIT],'typ',{'ign','es','bot','pit','pit'},'ax',ax,...
                'lbl',TPM.keys{j});
            if ~opt.hold
                ax = [];
                printfig([name '_metrics_' TPM.keys{j}]);
            end
        end
    end
    if opt.hold && opt.print
        printfig([name '_metrics_' TPM.keys{j}]);
    end

    TPM = struct2table(TPM);
    TPM.Properties.RowNames = TPM.keys; TPM.keys = [];
    TPM.Properties.Description = info;
    TPM.Properties.UserData.labels = [VAR;LBL]';
    TPM.Properties.UserData.name = name;
    TPM = sortrows(TPM,'discrepancy');
end

